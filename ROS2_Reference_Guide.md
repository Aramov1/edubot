# ROS2 Reference Guide (Python)

> **ROS** = Robot Operating System
> **ROS 2** = Recommended version (successor to ROS 1)
> **Distro used**: Jazzy

---

## Table of Contents

1. [Installation & Setup](#1-installation--setup)
2. [Workspace Setup](#2-workspace-setup)
3. [Creating a Python Package](#3-creating-a-python-package)
4. [Nodes](#4-nodes)
5. [Topics (Publisher / Subscriber)](#5-topics-publisher--subscriber)
6. [Services (Server / Client)](#6-services-server--client)
7. [Best Practices](#7-best-practices)
8. [ROS2 Command Reference](#8-ros2-command-reference)

---

## 1. Installation & Setup

Install any ROS2 package:

```bash
sudo apt install ros-<distro>-<package-name>
```

Source ROS2 in every terminal:

```bash
source /opt/ros/jazzy/setup.bash
```

Add to `~/.bashrc` so it loads automatically:

```bash
# Enable ROS2 Jazzy in every terminal
source /opt/ros/jazzy/setup.bash

# Enable colcon auto-completion
source /usr/share/colcon_argcomplete/hook/colcon-argcomplete.bash
```

After editing `.bashrc`, either open a new terminal or run:

```bash
source ~/.bashrc
```

---

## 2. Workspace Setup

A workspace is a folder that organizes your ROS2 code into packages. Convention is to name it `ros2_ws`.

```
ros2_ws/
├── src/          # Your packages and source code go here
├── build/        # Generated by colcon build
├── install/      # Built nodes are installed here
└── log/          # Build logs
```

### Create and build a workspace

```bash
mkdir -p ~/ros2_ws/src
cd ~/ros2_ws
colcon build
```

After building, source the workspace overlay:

```bash
source ~/ros2_ws/install/setup.bash
```

Add this to `~/.bashrc` so your custom nodes are always available:

```bash
source ~/ros2_ws/install/setup.bash
```

> **Tip**: Use `colcon build --symlink-install` so that Python nodes can be run immediately after editing without rebuilding (only works for nodes that were previously installed).

---

## 3. Creating a Python Package

Packages organize your nodes and their dependencies. Create packages inside the `src/` folder.

```bash
cd ~/ros2_ws/src
ros2 pkg create my_package --build-type ament_python --dependencies rclpy
```

- **Naming convention**: `<robot_name>_<function>` (e.g., `edubot_controller`)
- `--build-type ament_python` for Python packages (`ament_cmake` for C++)
- `--dependencies` lists packages this package depends on (e.g., `rclpy`, `geometry_msgs`)

### Package structure

```
my_package/
├── package.xml          # Package metadata and dependencies
├── setup.py             # Entry points for installing nodes
├── setup.cfg            # Tells ROS where nodes will be installed
├── my_package/          # Python module (same name as package)
│   ├── __init__.py
│   └── my_node.py       # Your node files go here
└── resource/
```

### Key files

**`package.xml`** - Add runtime dependencies here:

```xml
<depend>rclpy</depend>
<depend>geometry_msgs</depend>
<depend>example_interfaces</depend>
```

**`setup.py`** - Register nodes as executables:

```python
entry_points={
    'console_scripts': [
        'my_node = my_package.my_node:main',
    ],
},
```

### Build and run

```bash
cd ~/ros2_ws
colcon build
source ~/.bashrc
ros2 run my_package my_node
```

> **Important**: There are 3 different names to keep track of:
> 1. **Node name** - The name inside ROS2 (used in `super().__init__("node_name")`)
> 2. **File name** - The Python file (`my_node.py`)
> 3. **Executable name** - The name used with `ros2 run` (defined in `setup.py`)
>
> You can use the same name for all three to keep things simple.

---

## 4. Nodes

A node is a program connected to the ROS2 environment. Nodes communicate with each other through topics and services.

### Minimal node template

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node


class MyNode(Node):

    def __init__(self):
        super().__init__('my_node')  # Node name (all lowercase)
        self.get_logger().info('My Node has been started')


def main(args=None):
    rclpy.init(args=args)       # Start ROS2 communications
    node = MyNode()
    rclpy.spin(node)            # Keep node alive until killed
    rclpy.shutdown()            # Shut down ROS2 communications


if __name__ == '__main__':
    main()
```

**Key points:**
- Always call `rclpy.init(args=args)` before creating nodes
- `rclpy.spin(node)` keeps the node alive and processes callbacks
- Always call `rclpy.shutdown()` at the end
- Make files executable: `chmod +x my_node.py`

### Node with a timer

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node


class TimerNode(Node):

    def __init__(self):
        super().__init__('timer_node')
        self.get_logger().info('Timer Node has been started')
        self.create_timer(1.0, self.timer_callback)  # Call every 1 second

    def timer_callback(self):
        self.get_logger().info('Timer fired!')


def main(args=None):
    rclpy.init(args=args)
    node = TimerNode()
    rclpy.spin(node)
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

---

## 5. Topics (Publisher / Subscriber)

Topics enable **anonymous, one-way** communication between nodes. A publisher sends messages to a topic, and any number of subscribers can receive them.

- Each topic has a **name** (address) and a **message type** (data format)
- Publishers and subscribers are decoupled (anonymous)
- Topics can run at high frequencies (100+ Hz)
- A topic is created when a node publishes or subscribes to it

### Publisher example

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist


class DrawCircleNode(Node):

    def __init__(self):
        super().__init__('draw_circle')
        self.get_logger().info('Draw Circle Node has been started')

        # Create publisher: (msg_type, topic_name, queue_size)
        self.cmd_vel_pub_ = self.create_publisher(Twist, '/turtle1/cmd_vel', 10)

        # Publish at 10 Hz using a timer
        self.create_timer(0.1, self.send_velocity)

    def send_velocity(self):
        msg = Twist()
        msg.linear.x = 2.0
        msg.angular.z = 1.0
        self.cmd_vel_pub_.publish(msg)


def main(args=None):
    rclpy.init(args=args)
    node = DrawCircleNode()
    rclpy.spin(node)
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

**Naming convention**: `<topic_name>_pub_` for publisher attributes.

> Don't forget to add message dependencies to `package.xml`:
> ```xml
> <depend>geometry_msgs</depend>
> ```

### Subscriber example

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from turtlesim.msg import Pose


class PoseSubscriberNode(Node):

    def __init__(self):
        super().__init__('pose_subscriber')
        self.get_logger().info('Pose Subscriber Node has been started')

        # Create subscriber: (msg_type, topic_name, callback, queue_size)
        self.pose_sub_ = self.create_subscription(
            Pose, '/turtle1/pose', self.pose_callback, 10
        )

    def pose_callback(self, msg):
        self.get_logger().info(f'Position: x={msg.x:.2f}, y={msg.y:.2f}')


def main(args=None):
    rclpy.init(args=args)
    node = PoseSubscriberNode()
    rclpy.spin(node)
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

**Naming convention**: `<topic_name>_sub_` for subscriber attributes, `<what_you_receive>_callback` for callbacks.

### How to find topic info

```bash
ros2 topic list                              # List all active topics
ros2 topic info /turtle1/cmd_vel             # Show type and pub/sub count
ros2 topic type /turtle1/cmd_vel             # Show message type
ros2 interface show geometry_msgs/msg/Twist  # Show message fields
ros2 topic echo /turtle1/cmd_vel             # Listen to messages live
ros2 topic hz /turtle1/cmd_vel               # Measure publish frequency
```

---

## 6. Services (Server / Client)

Services provide **request-response** communication (unlike topics which are one-way). A client sends a request, the server processes it, and returns a response.

- Only **one server** per service, but **multiple clients** can connect
- Cannot be visualized with `rqt_graph` (use CLI tools instead)
- Use for **punctual calls** (computation, settings changes), not high-frequency data
- Services can have empty requests or responses

### Service server example

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts


class AddTwoIntsServerNode(Node):

    def __init__(self):
        super().__init__('add_two_ints_server')
        self.get_logger().info('Add Two Ints Server has been started')

        # Create service: (srv_type, service_name, callback)
        self.create_service(
            AddTwoInts, 'add_two_ints', self.add_two_ints_callback
        )

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(f'{request.a} + {request.b} = {response.sum}')
        return response


def main(args=None):
    rclpy.init(args=args)
    node = AddTwoIntsServerNode()
    rclpy.spin(node)
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

### Service client example

```python
#!/usr/bin/env python3
from functools import partial
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts


class AddTwoIntsClientNode(Node):

    def __init__(self):
        super().__init__('add_two_ints_client')
        self.get_logger().info('Add Two Ints Client has been started')
        self.call_add_two_ints_service(3, 7)

    def call_add_two_ints_service(self, a, b):
        # Create client
        client = self.create_client(AddTwoInts, 'add_two_ints')

        # Wait until the service is available
        while not client.wait_for_service(timeout_sec=1.0):
            self.get_logger().warn('Waiting for service...')

        # Create and fill the request
        request = AddTwoInts.Request()
        request.a = a
        request.b = b

        # Call asynchronously (non-blocking)
        future = client.call_async(request)
        future.add_done_callback(
            partial(self.callback_add_two_ints, a=a, b=b)
        )

    def callback_add_two_ints(self, future, a, b):
        try:
            response = future.result()
            self.get_logger().info(f'{a} + {b} = {response.sum}')
        except Exception as e:
            self.get_logger().error(f'Service call failed: {e}')


def main(args=None):
    rclpy.init(args=args)
    node = AddTwoIntsClientNode()
    rclpy.spin(node)
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

**Key points:**
- Always use `call_async()` instead of `call()` to avoid blocking
- Use `functools.partial` to pass extra arguments to the callback
- `wait_for_service()` checks if the server is running before sending requests
- Add service type dependencies to `package.xml` and as Python imports

### How to find service info

```bash
ros2 service list                                           # List active services
ros2 service type /add_two_ints                             # Show service type
ros2 interface show example_interfaces/srv/AddTwoInts       # Show request/response fields
ros2 service call /add_two_ints example_interfaces/srv/AddTwoInts "{'a': 2, 'b': 5}"  # Call from CLI
```

---

## 7. Best Practices

| Practice | Example |
|---|---|
| Always log node start | `self.get_logger().info('Node has been started')` |
| Publisher naming | `self.cmd_vel_pub_` |
| Subscriber naming | `self.pose_sub_` |
| Callback naming | `self.pose_callback` |
| Service call naming | `self.call_add_two_ints_service` |
| Node names in lowercase | `super().__init__('my_node')` |
| Use async service calls | `client.call_async(request)` not `client.call(request)` |
| Add all dependencies | Both in Python imports and `package.xml` |
| Use `--symlink-install` | `colcon build --symlink-install` to skip rebuild for Python |

### Logger levels

```python
self.get_logger().debug('Debug message')    # Not shown by default
self.get_logger().info('Info message')      # White
self.get_logger().warn('Warning message')   # Yellow
self.get_logger().error('Error message')    # Red
self.get_logger().fatal('Fatal message')    # Red
```

---

## 8. ROS2 Command Reference

### Node commands

| Command | Description |
|---|---|
| `ros2 run <package> <executable>` | Run a node |
| `ros2 node list` | List all running nodes |
| `ros2 node info /<node_name>` | Show node details (topics, services, etc.) |

### Topic commands

| Command | Description |
|---|---|
| `ros2 topic list` | List all active topics |
| `ros2 topic info <topic>` | Show message type and publisher/subscriber count |
| `ros2 topic type <topic>` | Show the message type of a topic |
| `ros2 topic echo <topic>` | Print messages being published to a topic |
| `ros2 topic hz <topic>` | Measure the publish frequency of a topic |
| `ros2 topic pub <topic> <type> <data>` | Publish a message from the command line |

### Service commands

| Command | Description |
|---|---|
| `ros2 service list` | List all active services |
| `ros2 service type <service>` | Show the service type |
| `ros2 service call <service> <type> <data>` | Call a service from the command line |

### Interface commands

| Command | Description |
|---|---|
| `ros2 interface show <type>` | Show fields of a message or service type |
| `ros2 interface list` | List all available message/service types |

### Package commands

| Command | Description |
|---|---|
| `ros2 pkg list` | List all available packages |
| `ros2 pkg create <name> --build-type ament_python --dependencies <deps>` | Create a new package |

### Build commands

| Command | Description |
|---|---|
| `colcon build` | Build all packages in the workspace |
| `colcon build --symlink-install` | Build with symlinks (skip rebuild for Python edits) |
| `colcon build --packages-select <pkg>` | Build only a specific package |

### Debugging / Visualization

| Command | Description |
|---|---|
| `rqt_graph` | Visualize the node/topic graph (does not show services) |
| `rqt` | Open the ROS2 GUI toolbox |

### Sourcing (required after build)

```bash
source /opt/ros/jazzy/setup.bash           # Source ROS2 installation
source ~/ros2_ws/install/setup.bash        # Source workspace overlay
source ~/.bashrc                           # Reload shell config
```